package nju.software.util;

import java.sql.*;

public final class DBUtil {
    private static String connect;
    private static String JDBC_DRIVER;
    private static String DB_URL;
    private static String USER;
    private static String PASS;
    private static boolean autoCommit;
    private static Connection conn;

    static {
        config();
    }

    private static void config(){
        //获取驱动
        JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
        //URL
        DB_URL = "jdbc:mysql://localhost:3306/sampledb?useSSL=false&serverTimezone=UTC";
        //数据库用户名
        USER = "root";
        //数据库密码
        PASS = "embark2015";
        //不自动提交
        autoCommit =false;
    }

    //载入数据库驱动
    private static boolean load() {
        try {
            Class.forName(JDBC_DRIVER);
            return true;
        } catch (ClassNotFoundException e) {
            System.out.println("驱动类 " + JDBC_DRIVER + " 加载失败");
        }

        return false;
    }

    //建立Connection
    public static Connection connect() {
        if (invalid()) { /* invalid为true时，说明连接是失败的 */
            /* 加载驱动 */
            load();
            try {
                /* 建立连接 */
                conn = DriverManager.getConnection(DB_URL, USER, PASS);
            } catch (SQLException e) {
                System.out.println("建立 " + connect + " 数据库连接失败 , " + e.getMessage());
            }
        }
        return conn;
    }

    //请求获得Statement对象
    public static Statement statement() {
        Statement st = null;
        connect();
        /* 如果连接是无效的就重新连接 */
        try {
            st = conn.createStatement();
        } catch (SQLException e) {
            System.out.println("创建 Statement 对象失败: " + e.getMessage());
        }
        return st;
    }

    /**
     * 根据给定的带参数占位符的SQL语句，创建 PreparedStatement 对象
     * @return 返回相应的 PreparedStatement 对象
     */
    private static PreparedStatement prepare(String SQL, boolean autoGeneratedKeys) {

        PreparedStatement ps = null;
        //请求并且获取Connection
        connect();
        try {
            if (autoGeneratedKeys) {
                ps = conn.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);
            } else {
                ps = conn.prepareStatement(SQL);
            }
        } catch (SQLException e) {
            System.out.println("创建 PreparedStatement 对象失败: " + e.getMessage());
        }

        return ps;

    }

    public static ResultSet query(String SQL, Object... params) {

        if (SQL == null || !SQL.trim().toLowerCase().startsWith("select")) {
            throw new RuntimeException("你的SQL语句为空或不是查询语句");
        }
        ResultSet rs = null;
        if (params.length > 0) {
            /* 有参数传入，需要处理参数 */
            PreparedStatement ps = prepare(SQL, false);
            try {
                for (int i = 0; i < params.length; i++) {
                    ps.setObject(i + 1, params[i]);
                }
                rs = ps.executeQuery();
            } catch (SQLException e) {
                System.out.println("执行SQL失败: " + e.getMessage());
            }
        } else {
            /* 说明没有传入任何参数 */
            Statement st = statement();
            try {
                // 直接执行不带参数的SQL语句
                rs = st.executeQuery(SQL);
            } catch (SQLException e) {
                System.out.println("执行SQL失败: " + e.getMessage());
            }
        }

        return rs;

    }





    //检查连接是否失效
    private static boolean invalid() {
        if (conn != null) {
            try {
                if (conn.isClosed()) {
                    return true;
                    // isValid方法是判断Connection是否有效,如果连接尚未关闭并且仍然有效，则返回 true
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            // conn 既不是 null 且也没有关闭 ，且 isValid 返回 true，说明是可以使用的 ( 返回 false )
            return false;
        } else {
            return true;
        }
    }

    //类型转换器
    private static Object typeof(Object o) {
        Object r = o;

        if (o instanceof Timestamp) {
            return r;
        }
        // 将 java.util.Date 转成 java.sql.Date
        if (o instanceof java.util.Date) {
            java.util.Date d = (java.util.Date) o;
            r = new Date(d.getTime());
            return r;
        }
        // 将 Character 或 char 变成 String
        if (o instanceof Character || o.getClass() == char.class) {
            r = String.valueOf(o);
            return r;
        }
        return r;
    }

    public static boolean execute(String SQL, Object... params) {
        if (SQL == null || SQL.trim().toLowerCase().startsWith("select")) {
            throw new RuntimeException("你的SQL语句为空或有错");
        }
        boolean result = false;
        SQL = SQL.trim();
        SQL = SQL.toLowerCase();
        if (params.length > 0) { // 说明有参数
            PreparedStatement ps = prepare(SQL, false);
            Connection conn = null;
            try {
                conn = ps.getConnection();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            try {
                for (int i = 0; i < params.length; i++) {
                    Object p = params[i];
                    p = typeof(p);
                    ps.setObject(i + 1, p);
                }
                ps.executeUpdate();
                result = true;
            } catch (SQLException e) {
                System.out.println(" 操作失败: " + e.getMessage());
            }

        } else { // 说明没有参数
            Statement st = statement();
            Connection conn = null;
            try {
                conn = st.getConnection();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            // 执行 DDL 或 DML 语句，并返回执行结果
            try {
                st.executeUpdate(SQL);
                result = true;
            } catch (SQLException e) {
                System.out.println(" 操作失败: " + e.getMessage());
            }
        }
        return result;
    }

    public static int insert(String SQL, boolean autoGeneratedKeys, Object... params) {
        int var = -1;
        if (SQL == null) {
            throw new RuntimeException("你没有指定SQL语句，请检查是否指定了需要执行的SQL语句");
        }
        // 如果不是 insert 开头开头的语句
        if (!SQL.trim().toLowerCase().startsWith("insert")) {
            System.out.println(SQL.toLowerCase());
            throw new RuntimeException("你指定的SQL语句不是插入语句，请检查你的SQL语句");
        }
        // 获得 被执行的 SQL 语句的 前缀 ( 第一个单词 )
        SQL = SQL.trim();
        SQL = SQL.toLowerCase();
        if (params.length > 0) { // 说明有参数
            PreparedStatement ps = prepare(SQL, autoGeneratedKeys);
            Connection c = null;
            try {
                c = ps.getConnection(); // 从 PreparedStatement 对象中获得 它对应的连接对象
            } catch (SQLException e) {
                e.printStackTrace();
            }
            try {
                for (int i = 0; i < params.length; i++) {
                    Object p = params[i];
                    p = typeof(p);
                    ps.setObject(i + 1, p);
                }
                int count = ps.executeUpdate();
                if (autoGeneratedKeys) { // 如果希望获得数据库产生的键
                    ResultSet rs = ps.getGeneratedKeys(); // 获得数据库产生的键集
                    if (rs.next()) { // 因为是保存的是单条记录，因此至多返回一个键
                        var = rs.getInt(1); // 获得值并赋值给 var 变量
                    }
                } else {
                    var = count; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
                }
            } catch (SQLException e) {
                System.out.println("数据保存失败: " + e.getMessage());
            }
        } else { // 说明没有参数
            Statement st = statement();
            Connection c = null;
            try {
                c = st.getConnection(); // 从 Statement 对象中获得 它对应的连接对象
            } catch (SQLException e) {
                e.printStackTrace();
            }
            // 执行 DDL 或 DML 语句，并返回执行结果
            try {
                int count = st.executeUpdate(SQL);
                if (autoGeneratedKeys) { // 如果企望获得数据库产生的键
                    ResultSet rs = st.getGeneratedKeys(); // 获得数据库产生的键集
                    if (rs.next()) { // 因为是保存的是单条记录，因此至多返回一个键
                        var = rs.getInt(1); // 获得值并赋值给 var 变量
                    }
                } else {
                    var = count; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
                }
            } catch (SQLException e) {
                System.out.println("数据保存失败: " + e.getMessage());
            }
        }
        return var;
    }


}
